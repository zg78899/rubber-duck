함수 선언식과 함수표현식의 차이점


함수선언식은 표현식이 아닌 문이다. 함수 선언식은 함수이름을 생략이 불가능하다. 함수선언은 키워드, 함수이름, 매겨변수의 목록,함수의 몸체로 이루어져있다. 그리고 함수의 호이스팅은 함수가 정의가 되면 함수객체를 생성하고 암묵적으로 함수이름과 같은 변수를 생성하고,이를 변수에 함수를 할당한다. 이는 모두 런타임이전에 실행된다. 선언문 이전에 접근할수있다.   함수는 선언하는것만으로는 내부의 코드가 실행되지않는다.  함수를 호출해주어야한다. 함수를 호출하는것은 함수이름이 아니라 자바스크립트가 암묵적으로 생성한 식별자이다.

함수리터럴은 표현식인 문이다.함수 리터럴은 값을 만드는게 일이다. 그리고 이것을 변수에 할당한다. 이렇게 하여 함수 표현식을 만든다. 함수 표현식의 구성은 함수선언식과 유사하지만 함수표현식은 함수의 이름으 생략(무명),혹은 생략하지 않기도하지만(기명) 흔히 생략을 하는것이 일반적이다. 
함수표현식의 호이스팅은 변수의 호이스팅과 동일하게 작동이 된다.

인수와 매개변수

인수가 매개변수보다 많은 경우-인수가 생략되는것 처럼보이지만  최상위 객체의 인수객체의 프로퍼티에 인수가 저장이 된다.
인수가 매개변수보다 적을때- 매개 변수는 변수와 같기 때문에 인수에서 값을 할 당해주기 전에 undefined을 반환하고 인수가 적게되면 반환값을 반환할때 인수가 하나만 들어가서 계산이 된다.
함수를 호출할때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러를 발생하지 않는다. 함수는 매개변수의 개수와 인수의 객수를 체크하지않는다. 

<hr>

스코프
var 키워드를 사용했을경우에  스코프를 함수가 스코프를 만든다. 스코프는 식별자를 찾는 규칙을 의미한다.자신이 선언되된 위치에 의해 다른 식별자를 참조할 유효범위를 결정한다.

자바스크립트엔진이 식별자를 찾는 규칙인데 코드와 가장 근접한 곳에있는 스코프를 먼저 본다.

스코프는 함수가 호출된 위치가 아니라, 정의된  위치에 의해서 결정이된다.

스코프는 전역와 지역으로 나뉘어진다. 전역과 지역은 중첨의 개념으로도 생각할 수있는데 전역은 부모 이고 지역은 자녀이다. 부모의 값은 자녀에게 상속되지만 자녀의 값은 부모가 사용할 수없다.
저녁은 어디에서든 참조가 가능하다. 스코프는 스코프 체인에 의해서 찾아지는데 이는 해당 스코프에서 상위로 이동한다. 결국에 가장 마지막에 도착하는 곳은 전역이다.
동적 스코프는 함수가 호출되는 곳에 의해서 정의된다. 정적스코프(렉시컬 스코프는)함수가 정의되는 위치에 의해서 스코프가 결정이 된다.

스코프의 생명주기는 짧을 수록 좋다.변수의 생명주기는 지역변수일때 함수의 생면주기와 일치한다.
전역 변수의 생명주기는 스크립트로드되자마자 생성되어 프로그램 애플리케이션이 죵료될대 까지 이다.
스코프의 생변주기를 짧게하면 가독성이 좋고,리소스 적게 들게 되어 좋다.또한 여러 일이 아니라 한가지 일만을 하게 시킬수있다는 장점이 있다.

또한 자바스크립트는 파일스코프를 가지고 있지않는다. 때문에 여러개의 스크립트 파일들을 불러오게되면 하나로 합쳐진것 처럼 동작한다. 이런 상황에서 var 키워드를 사용한 경우에 같은 변수이름을 사용한 경우에 암묵적으로 재할당이 되어 값이 변경되는 부작용이 발생할 수잇다.

전역변수의 문제점

var키워드를 사용했을경우.

1. 암묵적인 결합-전역함수 안에서 변수를 선언하지않고 값만을 할당하면 이를 전역변수로 암적으로 생성한다.

2. 생명주기가 길다. 이로인해서 변경될수있는 시간도 길고 , 메모리 리소스도 많이 사용한다,
   더욱이 var키워드는 변수의 중복선언을 허용하므로  의도치 않은 재할당이 이루어질 수있다.

3. 스코프 체인사의 종점이 존재한다. -스코프체인이 식별자를 검색할때 가방 마지막에 검색을 하는 것이 전역이기때문에 검색속도가 가장느리다.

4. 네임 스페이스가 오염된다.-파일이 분리 되어있더라도 하나의 전역 스코프를 공유한다. 따라서 다른 파일내에 동이랗ㄴ 이름으로 명명된 변수나 함수가 같은 스코프내에 존재할 경우 예상치 못한 결과를 가져올수있다.

   <hr>

   const는 상수이다. 상수는 변하지 않는 값이다. 그리고 재할당을 금지하고있다. const키워드는 선언과 동시에 할당을 해야한다. 또한 상수의 경우에는 변수이름을 대문자를 사용해 파스칼 케이스를 사용하여  변수가 상수라는 것을 알아볼수있게 약속을 한다.

   let키워드는 변수이다.따라서 재할당이 가능하지만 재선언을 불가능하다.

   const와 let은 최상위 전역객체가 window객체가 아니다.
   또한 const 와let은 변수 호이스팅이되지만 호이스팅이 되지 않는것 처럼 보인다. 선언문은 런타임 이전에 선언되지만 할당은 런타임의 선언문에 와야 된다. 그때문에 호이스팅이 안되는 것 처럼 보인다.

   var 키워드는 재선언이 가장하기때문에 값이 배할당되어 의도치 않게값이 변경되는 부작용이 발생하는 경우가 있다. 

   Es6에서는 var 키워드를 사용하지 않는다.  앞에서 살펴본 앞에서의 여러가지 문제점들이 있기 때문이다. 대부분의 변수들은 es6 에서는 const를 사용하여 선언을 한다. 그리고 재할당을 해여하는 경우에  let키워드는 사용하여 변수를 선언하자. 

   ~~~javascript
   function foo(){}
   ~~~

   다음 함수선언문은 식별자가 window객체에 저장이 된다. 이는 마치 var키워드를 사용하여 선언한것처럼 식별자가 저장이 된다.(const/let은 전역객체가 window에 속하지않기 때문에 )함수선언문의 식별자가 var 키워드 처럼 저장이 되는 이유는 -하위 호환성 때문이다.

